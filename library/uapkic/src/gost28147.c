/*
 * Copyright 2021 The UAPKI Project Authors.
 * Copyright 2016 PrivatBank IT <acsk@privatbank.ua>
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are 
 * met:
 * 
 * 1. Redistributions of source code must retain the above copyright 
 * notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright 
 * notice, this list of conditions and the following disclaimer in the 
 * documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS 
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED 
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#define FILE_MARKER "uapkic/gost28147.c"

#include <string.h>
#include <stdbool.h>

#include "gost28147.h"
#include "drbg.h"
#include "byte-array-internal.h"
#include "byte-utils-internal.h"
#include "macros-internal.h"

#define SBOX_LEN                 128
#define KEY_LEN                  32
#define IV_LEN                   8

typedef enum {
    GOST28147_MODE_ECB = 1,
    GOST28147_MODE_CTR = 2,
    GOST28147_MODE_CFB = 3,
    GOST28147_MODE_MAC = 4
} Gost28147Mode;

typedef struct Gost28147CtrCtx_st {
    size_t offset;
    uint8_t gamma[24];
    uint32_t feed[6];
} Gost28147CtrCtx;

typedef struct Gost28147CfbCtx_st {
    size_t offset;
    uint8_t gamma[8];
    uint8_t feed[8];
} Gost28147CfbCtx;

typedef struct Gost28147MacCtx_st {
    size_t offset;
    uint8_t mac[8];
} Gost28147MacCtx;

struct Gost28147Ctx_st {
    Gost28147Mode mode_id;
    bool inited;
    ByteArray *sbox128;
    uint32_t sbox[1024];
    uint32_t key[KEY_LEN / UINT32_LEN];

    union {
        Gost28147CtrCtx ctr;
        Gost28147CfbCtx cfb;
        Gost28147MacCtx mac;
    } mode;
};

static const uint8_t GOST28147_SBOX_1[SBOX_LEN] = {
    0xa, 0x9, 0xd, 0x6, 0xe, 0xb, 0x4, 0x5, 0xf, 0x1, 0x3, 0xc, 0x7, 0x0, 0x8, 0x2,
    0x8, 0x0, 0xc, 0x4, 0x9, 0x6, 0x7, 0xb, 0x2, 0x3, 0x1, 0xf, 0x5, 0xe, 0xa, 0xd,
    0xf, 0x6, 0x5, 0x8, 0xe, 0xb, 0xa, 0x4, 0xc, 0x0, 0x3, 0x7, 0x2, 0x9, 0x1, 0xd,
    0x3, 0x8, 0xd, 0x9, 0x6, 0xb, 0xf, 0x0, 0x2, 0x5, 0xc, 0xa, 0x4, 0xe, 0x1, 0x7,
    0xf, 0x8, 0xe, 0x9, 0x7, 0x2, 0x0, 0xd, 0xc, 0x6, 0x1, 0x5, 0xb, 0x4, 0x3, 0xa,
    0x2, 0x8, 0x9, 0x7, 0x5, 0xf, 0x0, 0xb, 0xc, 0x1, 0xd, 0xe, 0xa, 0x3, 0x6, 0x4,
    0x3, 0x8, 0xb, 0x5, 0x6, 0x4, 0xe, 0xa, 0x2, 0xc, 0x1, 0x7, 0x9, 0xf, 0xd, 0x0,
    0x1, 0x2, 0x3, 0xe, 0x6, 0xd, 0xb, 0x8, 0xf, 0xa, 0xc, 0x5, 0x7, 0x9, 0x0, 0x4,
};

static const uint8_t GOST28147_SBOX_2[SBOX_LEN] = {
    0xe, 0x9, 0x3, 0x7, 0xf, 0x4, 0xc, 0xb, 0x6, 0xa, 0xd, 0x1, 0x0, 0x5, 0x8, 0x2,
    0xa, 0xd, 0xc, 0x7, 0x6, 0xe, 0x8, 0x1, 0xf, 0x3, 0xb, 0x4, 0x0, 0x9, 0x5, 0x2,
    0x4, 0xb, 0x1, 0xf, 0x9, 0x2, 0xe, 0xc, 0x6, 0xa, 0x8, 0x7, 0x3, 0x5, 0x0, 0xd,
    0x4, 0x5, 0x1, 0xc, 0x7, 0xe, 0x9, 0x2, 0xa, 0xf, 0xb, 0xd, 0x0, 0x8, 0x6, 0x3,
    0xc, 0xb, 0x3, 0x9, 0xf, 0x0, 0x4, 0x5, 0x7, 0x2, 0xe, 0xd, 0x1, 0xa, 0x8, 0x6,
    0x8, 0x7, 0x3, 0xa, 0x9, 0x6, 0xe, 0x5, 0xd, 0x0, 0x4, 0xc, 0x1, 0x2, 0xf, 0xb,
    0xf, 0x0, 0xe, 0x6, 0x8, 0xd, 0x5, 0x9, 0xa, 0x3, 0x1, 0xc, 0x4, 0xb, 0x7, 0x2,
    0x4, 0x3, 0xe, 0xd, 0x5, 0x0, 0x2, 0xb, 0x1, 0xa, 0x7, 0x6, 0x9, 0xf, 0x8, 0xc,
};

static const uint8_t GOST28147_SBOX_3[SBOX_LEN] = {
    0xd, 0x9, 0x1, 0xe, 0x7, 0x2, 0xc, 0x5, 0x4, 0xb, 0x6, 0xf, 0x3, 0x8, 0xa, 0x0,
    0x7, 0x8, 0x6, 0xb, 0x0, 0x3, 0x4, 0xd, 0x9, 0x5, 0xf, 0xe, 0xa, 0xc, 0x2, 0x1,
    0xa, 0x5, 0x3, 0xc, 0x9, 0x8, 0xd, 0x6, 0x4, 0xf, 0xe, 0x0, 0x2, 0xb, 0x1, 0x7,
    0xb, 0xa, 0xc, 0x1, 0x5, 0x6, 0x9, 0xe, 0x2, 0xd, 0xf, 0x7, 0x0, 0x4, 0x3, 0x8,
    0x5, 0xb, 0x3, 0x0, 0xf, 0x9, 0xe, 0x4, 0x1, 0xc, 0x8, 0x6, 0x2, 0xa, 0x7, 0xd,
    0x4, 0x3, 0xb, 0xd, 0x1, 0xf, 0x8, 0x2, 0x7, 0xe, 0xc, 0x9, 0xa, 0x0, 0x6, 0x5,
    0x3, 0x7, 0x8, 0xb, 0x1, 0xe, 0x5, 0x0, 0xd, 0x4, 0xc, 0xa, 0x2, 0x9, 0xf, 0x6,
    0x6, 0xd, 0xc, 0xa, 0xb, 0x7, 0x9, 0x3, 0xf, 0xe, 0x1, 0x2, 0x0, 0x8, 0x4, 0x5,
};

static const uint8_t GOST28147_SBOX_4[SBOX_LEN] = {
    0x9, 0xc, 0x3, 0xd, 0x7, 0x6, 0xe, 0x1, 0xa, 0x2, 0x0, 0x4, 0x8, 0xf, 0x5, 0xb,
    0xa, 0x5, 0xb, 0xe, 0x7, 0x6, 0x0, 0xc, 0x2, 0x8, 0xf, 0x4, 0xd, 0x3, 0x9, 0x1,
    0x4, 0xc, 0x3, 0x0, 0xd, 0x2, 0xe, 0xb, 0x7, 0xf, 0x5, 0x9, 0x1, 0x8, 0xa, 0x6,
    0x3, 0x9, 0x4, 0x5, 0xe, 0x7, 0x8, 0x6, 0xd, 0x0, 0x2, 0xf, 0xb, 0xc, 0xa, 0x1,
    0x2, 0x9, 0xc, 0xf, 0xd, 0xb, 0x4, 0x1, 0x7, 0x5, 0x3, 0xe, 0x6, 0x8, 0xa, 0x0,
    0xe, 0x5, 0xd, 0xb, 0x1, 0x9, 0x4, 0x2, 0xf, 0x8, 0x7, 0x0, 0x3, 0xc, 0xa, 0x6,
    0xe, 0x6, 0x5, 0xa, 0x9, 0xd, 0x4, 0x8, 0xb, 0xc, 0x0, 0x3, 0x7, 0x1, 0xf, 0x2,
    0x1, 0x9, 0xc, 0xb, 0x7, 0x6, 0x8, 0x3, 0x2, 0xf, 0xe, 0x0, 0x5, 0xa, 0x4, 0xd,
};

static const uint8_t GOST28147_SBOX_5[SBOX_LEN] = {
    0x3, 0x4, 0xd, 0x8, 0xc, 0x7, 0xa, 0x2, 0x0, 0xe, 0x9, 0xf, 0xb, 0x1, 0x5, 0x6,
    0xc, 0x7, 0x6, 0x9, 0x3, 0x8, 0xb, 0x5, 0xf, 0xa, 0x0, 0xd, 0x4, 0x2, 0x1, 0xe,
    0xe, 0x4, 0x8, 0x7, 0xb, 0x3, 0xa, 0xc, 0x1, 0x2, 0x6, 0x9, 0xd, 0xf, 0x0, 0x5,
    0x3, 0x9, 0x6, 0xd, 0x8, 0xf, 0xa, 0x2, 0x7, 0xe, 0xc, 0x0, 0xb, 0x4, 0x1, 0x5,
    0x5, 0xc, 0xa, 0x7, 0x2, 0x1, 0xf, 0xd, 0xe, 0x3, 0xb, 0x4, 0x0, 0x8, 0x9, 0x6,
    0x1, 0x8, 0xb, 0xe, 0x7, 0x4, 0xa, 0x0, 0xc, 0x3, 0x5, 0xd, 0x9, 0xf, 0x6, 0x2,
    0x9, 0xb, 0xa, 0xd, 0x5, 0xe, 0x2, 0x3, 0x0, 0x6, 0x4, 0xc, 0xf, 0x1, 0x7, 0x8,
    0xe, 0x9, 0x1, 0x8, 0x5, 0xf, 0xb, 0x0, 0x6, 0x2, 0xc, 0x7, 0xa, 0x4, 0xd, 0x3,
};

static const uint8_t GOST28147_SBOX_6[SBOX_LEN] = {
    0xf, 0xc, 0x9, 0x6, 0xe, 0x2, 0x1, 0xb, 0x0, 0xd, 0x4, 0xa, 0x7, 0x8, 0x3, 0x5,
    0xe, 0xc, 0x5, 0x0, 0x7, 0x4, 0xa, 0x3, 0x2, 0x6, 0x1, 0xd, 0x9, 0xb, 0xf, 0x8,
    0x5, 0x6, 0xd, 0x9, 0xb, 0xe, 0xa, 0x3, 0xf, 0x2, 0x8, 0x1, 0x4, 0x0, 0x7, 0xc,
    0x1, 0xf, 0x7, 0x4, 0x2, 0xe, 0xc, 0x3, 0x6, 0xb, 0x9, 0x8, 0x0, 0x5, 0xa, 0xd,
    0xf, 0x9, 0xe, 0x6, 0xd, 0x1, 0x5, 0x8, 0x4, 0x2, 0x3, 0xc, 0xa, 0xb, 0x0, 0x7,
    0xb, 0x0, 0xd, 0x7, 0xc, 0xe, 0x1, 0x4, 0x2, 0x3, 0x6, 0x8, 0xa, 0x5, 0xf, 0x9,
    0x7, 0xe, 0xf, 0x8, 0xd, 0x0, 0xb, 0x3, 0xa, 0x1, 0x4, 0x2, 0x9, 0xc, 0x6, 0x5,
    0x1, 0x5, 0xe, 0xb, 0x2, 0xc, 0x3, 0x8, 0xa, 0x0, 0x9, 0x7, 0xf, 0x6, 0x4, 0xd,
};

static const uint8_t GOST28147_SBOX_7[SBOX_LEN] = {
    0xf, 0xd, 0xa, 0x5, 0xc, 0x0, 0x1, 0x6, 0x9, 0x2, 0xe, 0x7, 0x3, 0xb, 0x4, 0x8,
    0x2, 0x5, 0xa, 0x0, 0x6, 0x9, 0x1, 0xf, 0xd, 0x4, 0x7, 0xe, 0xb, 0x3, 0x8, 0xc,
    0x3, 0xe, 0x4, 0xb, 0x5, 0x9, 0x1, 0x2, 0xf, 0x6, 0x8, 0xd, 0x7, 0x0, 0xa, 0xc,
    0x4, 0xa, 0xb, 0x9, 0xf, 0x2, 0xe, 0x5, 0xd, 0x1, 0x3, 0x6, 0x0, 0x7, 0xc, 0x8,
    0xf, 0x6, 0x5, 0x8, 0x9, 0x7, 0xc, 0xb, 0x0, 0xa, 0x3, 0x1, 0x2, 0x4, 0xd, 0xe,
    0xc, 0xb, 0xf, 0x4, 0x5, 0x1, 0xe, 0x9, 0x0, 0x8, 0xd, 0x2, 0xa, 0x7, 0x3, 0x6,
    0xd, 0x2, 0x4, 0x8, 0xb, 0xc, 0x1, 0x3, 0xa, 0x5, 0x9, 0xe, 0x7, 0xf, 0x0, 0x6,
    0x1, 0x5, 0x0, 0xf, 0x6, 0xa, 0x3, 0xe, 0x7, 0x2, 0xc, 0xd, 0xb, 0x8, 0x9, 0x4,
};

static const uint8_t GOST28147_SBOX_8[SBOX_LEN] = {
    0xe, 0x4, 0xb, 0x2, 0x8, 0x7, 0x5, 0xc, 0x9, 0xd, 0x0, 0x3, 0x1, 0xf, 0x6, 0xa,
    0x3, 0xe, 0xc, 0xa, 0x6, 0x2, 0xd, 0x1, 0x9, 0x8, 0x7, 0x4, 0x0, 0xf, 0x5, 0xb,
    0x5, 0x2, 0x8, 0x7, 0x1, 0xf, 0xe, 0x6, 0x4, 0xd, 0xb, 0x0, 0xa, 0x3, 0xc, 0x9,
    0xc, 0xa, 0x7, 0xd, 0xe, 0x3, 0x0, 0x2, 0x9, 0x5, 0x1, 0x6, 0xb, 0x4, 0xf, 0x8,
    0x6, 0x3, 0xf, 0x7, 0x0, 0x9, 0xa, 0x8, 0xb, 0xc, 0x4, 0x1, 0x5, 0x2, 0xd, 0xe,
    0x6, 0xd, 0xf, 0x1, 0x5, 0x3, 0x8, 0x0, 0xb, 0xa, 0xe, 0x4, 0x9, 0xc, 0x2, 0x7,
    0x2, 0xf, 0xc, 0x5, 0xb, 0x1, 0x3, 0xe, 0x0, 0x6, 0xd, 0xa, 0x7, 0x9, 0x4, 0x8,
    0x3, 0x0, 0x5, 0xc, 0x8, 0xf, 0xd, 0xe, 0xb, 0x6, 0x2, 0x9, 0x7, 0x1, 0x4, 0xa,
};

static const uint8_t GOST28147_SBOX_9[SBOX_LEN] = {
    0x9, 0x0, 0xb, 0xc, 0x2, 0x4, 0x3, 0xf, 0xd, 0x6, 0xe, 0x1, 0xa, 0x7, 0x5, 0x8,
    0x3, 0x5, 0x0, 0xf, 0x8, 0x7, 0xe, 0xc, 0xd, 0xa, 0x1, 0x6, 0xb, 0x2, 0x4, 0x9,
    0x8, 0x4, 0x5, 0xa, 0xe, 0xb, 0xd, 0x6, 0xc, 0xf, 0x7, 0x9, 0x3, 0x1, 0x2, 0x0,
    0x5, 0x4, 0xf, 0x0, 0xc, 0xb, 0xa, 0x9, 0x1, 0xe, 0x8, 0x6, 0x3, 0x2, 0xd, 0x7,
    0x7, 0xc, 0x3, 0x0, 0x6, 0x8, 0xe, 0xb, 0x1, 0xf, 0xd, 0xa, 0x9, 0x5, 0x2, 0x4,
    0x7, 0x4, 0x3, 0xb, 0x6, 0xa, 0x8, 0x1, 0x9, 0xc, 0xe, 0xd, 0x0, 0xf, 0x2, 0x5,
    0x7, 0xe, 0x9, 0xf, 0x1, 0x4, 0x8, 0x3, 0xb, 0xd, 0x0, 0x2, 0x6, 0xa, 0x5, 0xc,
    0xe, 0x2, 0x8, 0xf, 0x3, 0x0, 0x7, 0xc, 0xb, 0xd, 0x1, 0x5, 0x6, 0x4, 0x9, 0xa,
};

static const uint8_t GOST28147_SBOX_10[SBOX_LEN] = {
    0x8, 0x4, 0x6, 0x9, 0xb, 0xc, 0x1, 0x2, 0x3, 0x7, 0xe, 0x0, 0xd, 0xa, 0xf, 0x5,
    0x7, 0xd, 0x1, 0x8, 0xa, 0xe, 0x4, 0xf, 0x9, 0x0, 0x6, 0x3, 0x2, 0xc, 0xb, 0x5,
    0xc, 0x8, 0xd, 0x1, 0xa, 0x2, 0x9, 0x6, 0x3, 0x4, 0xe, 0x7, 0x5, 0xf, 0x0, 0xb,
    0x2, 0xb, 0x3, 0x4, 0xc, 0x7, 0x9, 0xd, 0xf, 0x8, 0x5, 0x0, 0x1, 0xe, 0xa, 0x6,
    0x8, 0x3, 0xd, 0xa, 0xe, 0xf, 0x5, 0x1, 0x4, 0x7, 0xb, 0xc, 0x2, 0x0, 0x6, 0x9,
    0x4, 0xc, 0x9, 0xb, 0xe, 0xa, 0x7, 0x6, 0x3, 0x5, 0x0, 0xf, 0x1, 0x2, 0x8, 0xd,
    0x5, 0x8, 0xe, 0x7, 0x3, 0x0, 0x1, 0xd, 0xa, 0x6, 0x9, 0x2, 0xf, 0xb, 0xc, 0x4,
    0xa, 0x3, 0x5, 0x9, 0x0, 0xd, 0x7, 0x8, 0xc, 0x4, 0x1, 0x6, 0xb, 0xf, 0x2, 0xe,
};

/* This is an s-box from RFC4357, named GostR3411-94-TestParamSet*/
static const uint8_t GOST28147_SBOX_11[SBOX_LEN] = {
    0x4, 0xa, 0x9, 0x2, 0xd, 0x8, 0x0, 0xe, 0x6, 0xb, 0x1, 0xc, 0x7, 0xf, 0x5, 0x3,
    0xe, 0xb, 0x4, 0xc, 0x6, 0xd, 0xf, 0xa, 0x2, 0x3, 0x8, 0x1, 0x0, 0x7, 0x5, 0x9,
    0x5, 0x8, 0x1, 0xd, 0xa, 0x3, 0x4, 0x2, 0xe, 0xf, 0xc, 0x7, 0x6, 0x0, 0x9, 0xb,
    0x7, 0xd, 0xa, 0x1, 0x0, 0x8, 0x9, 0xf, 0xe, 0x4, 0x6, 0xc, 0xb, 0x2, 0x5, 0x3,
    0x6, 0xc, 0x7, 0x1, 0x5, 0xf, 0xd, 0x8, 0x4, 0xa, 0x9, 0xe, 0x0, 0x3, 0xb, 0x2,
    0x4, 0xb, 0xa, 0x0, 0x7, 0x2, 0x1, 0xd, 0x3, 0x6, 0x8, 0x5, 0x9, 0xc, 0xf, 0xe,
    0xd, 0xb, 0x4, 0x1, 0x3, 0xf, 0x5, 0x9, 0x0, 0xa, 0xe, 0x7, 0x6, 0x8, 0x2, 0xc,
    0x1, 0xf, 0xd, 0x0, 0x5, 0x7, 0xa, 0x4, 0x9, 0x2, 0x3, 0xe, 0x6, 0xb, 0x8, 0xc
};

static const uint8_t GOST28147_SBOX_12[SBOX_LEN] = {
    0x4, 0x2, 0xf, 0x5, 0x9, 0x1, 0x0, 0x8, 0xe, 0x3, 0xb, 0xc, 0xd, 0x7, 0xa, 0x6,
    0xc, 0x9, 0xf, 0xe, 0x8, 0x1, 0x3, 0xa, 0x2, 0x7, 0x4, 0xd, 0x6, 0x0, 0xb, 0x5,
    0xd, 0x8, 0xe, 0xc, 0x7, 0x3, 0x9, 0xa, 0x1, 0x5, 0x2, 0x4, 0x6, 0xf, 0x0, 0xb,
    0xe, 0x9, 0xb, 0x2, 0x5, 0xf, 0x7, 0x1, 0x0, 0xd, 0xc, 0x6, 0xa, 0x4, 0x3, 0x8,
    0x3, 0xe, 0x5, 0x9, 0x6, 0x8, 0x0, 0xd, 0xa, 0xb, 0x7, 0xc, 0x2, 0x1, 0xf, 0x4,
    0x8, 0xf, 0x6, 0xb, 0x1, 0x9, 0xc, 0x5, 0xd, 0x3, 0x7, 0xa, 0x0, 0xe, 0x2, 0x4,
    0x9, 0xb, 0xc, 0x0, 0x3, 0x6, 0x7, 0x5, 0x4, 0x8, 0xe, 0xf, 0x1, 0xa, 0x2, 0xd,
    0xc, 0x6, 0x5, 0x2, 0xb, 0x0, 0x9, 0xd, 0x3, 0xe, 0x7, 0xa, 0xf, 0x4, 0x1, 0x8
};

static const uint8_t GOST28147_SBOX_13[SBOX_LEN] = {
    0x9, 0x6, 0x3, 0x2, 0x8, 0xb, 0x1, 0x7, 0xa, 0x4, 0xe, 0xf, 0xc, 0x0, 0xd, 0x5,
    0x3, 0x7, 0xe, 0x9, 0x8, 0xa, 0xf, 0x0, 0x5, 0x2, 0x6, 0xc, 0xb, 0x4, 0xd, 0x1,
    0xe, 0x4, 0x6, 0x2, 0xb, 0x3, 0xd, 0x8, 0xc, 0xf, 0x5, 0xa, 0x0, 0x7, 0x1, 0x9,
    0xe, 0x7, 0xa, 0xc, 0xd, 0x1, 0x3, 0x9, 0x0, 0x2, 0xb, 0x4, 0xf, 0x8, 0x5, 0x6,
    0xb, 0x5, 0x1, 0x9, 0x8, 0xd, 0xf, 0x0, 0xe, 0x4, 0x2, 0x3, 0xc, 0x7, 0xa, 0x6,
    0x3, 0xa, 0xd, 0xc, 0x1, 0x2, 0x0, 0xb, 0x7, 0x5, 0x9, 0x4, 0x8, 0xf, 0xe, 0x6,
    0x1, 0xd, 0x2, 0x9, 0x7, 0xa, 0x6, 0x0, 0x8, 0xc, 0x4, 0x5, 0xf, 0x3, 0xb, 0xe,
    0xb, 0xa, 0xf, 0x5, 0x0, 0xc, 0xe, 0x8, 0x6, 0x2, 0x3, 0x9, 0x1, 0x7, 0xd, 0x4
};

static const uint8_t GOST28147_SBOX_14[SBOX_LEN] = {
    0x8, 0x4, 0xb, 0x1, 0x3, 0x5, 0x0, 0x9, 0x2, 0xe, 0xa, 0xc, 0xd, 0x6, 0x7, 0xf,
    0x0, 0x1, 0x2, 0xa, 0x4, 0xd, 0x5, 0xc, 0x9, 0x7, 0x3, 0xf, 0xb, 0x8, 0x6, 0xe,
    0xe, 0xc, 0x0, 0xa, 0x9, 0x2, 0xd, 0xb, 0x7, 0x5, 0x8, 0xf, 0x3, 0x6, 0x1, 0x4,
    0x7, 0x5, 0x0, 0xd, 0xb, 0x6, 0x1, 0x2, 0x3, 0xa, 0xc, 0xf, 0x4, 0xe, 0x9, 0x8,
    0x2, 0x7, 0xc, 0xf, 0x9, 0x5, 0xa, 0xb, 0x1, 0x4, 0x0, 0xd, 0x6, 0x8, 0xe, 0x3,
    0x8, 0x3, 0x2, 0x6, 0x4, 0xd, 0xe, 0xb, 0xc, 0x1, 0x7, 0xf, 0xa, 0x0, 0x9, 0x5,
    0x5, 0x2, 0xa, 0xb, 0x9, 0x1, 0xc, 0x3, 0x7, 0x4, 0xd, 0x0, 0x6, 0xf, 0x8, 0xe,
    0x0, 0x4, 0xb, 0xe, 0x8, 0x3, 0x7, 0x1, 0xa, 0x2, 0x9, 0x6, 0xf, 0xd, 0x5, 0xc
};

static const uint8_t GOST28147_SBOX_15[SBOX_LEN] = {
    0x1, 0xb, 0xc, 0x2, 0x9, 0xd, 0x0, 0xf, 0x4, 0x5, 0x8, 0xe, 0xa, 0x7, 0x6, 0x3,
    0x0, 0x1, 0x7, 0xd, 0xb, 0x4, 0x5, 0x2, 0x8, 0xe, 0xf, 0xc, 0x9, 0xa, 0x6, 0x3,
    0x8, 0x2, 0x5, 0x0, 0x4, 0x9, 0xf, 0xa, 0x3, 0x7, 0xc, 0xd, 0x6, 0xe, 0x1, 0xb,
    0x3, 0x6, 0x0, 0x1, 0x5, 0xd, 0xa, 0x8, 0xb, 0x2, 0x9, 0x7, 0xe, 0xf, 0xc, 0x4,
    0x8, 0xd, 0xb, 0x0, 0x4, 0x5, 0x1, 0x2, 0x9, 0x3, 0xc, 0xe, 0x6, 0xf, 0xa, 0x7,
    0xc, 0x9, 0xb, 0x1, 0x8, 0xe, 0x2, 0x4, 0x7, 0x3, 0x6, 0x5, 0xa, 0x0, 0xf, 0xd,
    0xa, 0x9, 0x6, 0x8, 0xd, 0xe, 0x2, 0x0, 0xf, 0x3, 0x5, 0xb, 0x4, 0x1, 0xc, 0x7,
    0x7, 0x4, 0x0, 0x5, 0xa, 0x2, 0xf, 0xe, 0xc, 0x6, 0x1, 0xb, 0xd, 0x9, 0x3, 0x8
};

static const uint8_t GOST28147_SBOX_16[SBOX_LEN] = {
    0xf, 0xc, 0x2, 0xa, 0x6, 0x4, 0x5, 0x0, 0x7, 0x9, 0xe, 0xd, 0x1, 0xb, 0x8, 0x3,
    0xb, 0x6, 0x3, 0x4, 0xc, 0xf, 0xe, 0x2, 0x7, 0xd, 0x8, 0x0, 0x5, 0xa, 0x9, 0x1,
    0x1, 0xc, 0xb, 0x0, 0xf, 0xe, 0x6, 0x5, 0xa, 0xd, 0x4, 0x8, 0x9, 0x3, 0x7, 0x2,
    0x1, 0x5, 0xe, 0xc, 0xa, 0x7, 0x0, 0xd, 0x6, 0x2, 0xb, 0x4, 0x9, 0x3, 0xf, 0x8,
    0x0, 0xc, 0x8, 0x9, 0xd, 0x2, 0xa, 0xb, 0x7, 0x3, 0x6, 0x5, 0x4, 0xe, 0xf, 0x1,
    0x8, 0x0, 0xf, 0x3, 0x2, 0x5, 0xe, 0xb, 0x1, 0xa, 0x4, 0x7, 0xc, 0x9, 0xd, 0x6,
    0x3, 0x0, 0x6, 0xf, 0x1, 0xe, 0x9, 0x2, 0xd, 0x8, 0xc, 0x4, 0xb, 0xa, 0x5, 0x7,
    0x1, 0xa, 0x6, 0x8, 0xf, 0xb, 0x0, 0x4, 0xc, 0x3, 0x5, 0x9, 0x7, 0xd, 0x2, 0xe
};

static const uint8_t GOST28147_SBOX_17[SBOX_LEN] = {
    0xa, 0x4, 0x5, 0x6, 0x8, 0x1, 0x3, 0x7, 0xd, 0xc, 0xe, 0x0, 0x9, 0x2, 0xb, 0xf,
    0x5, 0xf, 0x4, 0x0, 0x2, 0xd, 0xb, 0x9, 0x1, 0x7, 0x6, 0x3, 0xc, 0xe, 0xa, 0x8,
    0x7, 0xf, 0xc, 0xe, 0x9, 0x4, 0x1, 0x0, 0x3, 0xb, 0x5, 0x2, 0x6, 0xa, 0x8, 0xd,
    0x4, 0xa, 0x7, 0xc, 0x0, 0xf, 0x2, 0x8, 0xe, 0x1, 0x6, 0x5, 0xd, 0xb, 0x9, 0x3,
    0x7, 0x6, 0x4, 0xb, 0x9, 0xc, 0x2, 0xa, 0x1, 0x8, 0x0, 0xe, 0xf, 0xd, 0x3, 0x5,
    0x7, 0x6, 0x2, 0x4, 0xd, 0x9, 0xf, 0x0, 0xa, 0x1, 0x5, 0xb, 0x8, 0xe, 0xc, 0x3,
    0xd, 0xe, 0x4, 0x1, 0x7, 0x0, 0x5, 0xa, 0x3, 0xc, 0x8, 0xf, 0x6, 0x2, 0x9, 0xb,
    0x1, 0x3, 0xa, 0x9, 0x5, 0xb, 0x4, 0xf, 0x8, 0x6, 0x7, 0xe, 0xd, 0x0, 0x2, 0xc
};

/* 1.2.643.2.2.31.1 */
static const uint8_t GOST28147_SBOX_18[SBOX_LEN] = {
    0xB, 0xA, 0xF, 0x5, 0x0, 0xC, 0xE, 0x8, 0x6, 0x2, 0x3, 0x9, 0x1, 0x7, 0xD, 0x4,
    0x1, 0xD, 0x2, 0x9, 0x7, 0xA, 0x6, 0x0, 0x8, 0xC, 0x4, 0x5, 0xF, 0x3, 0xB, 0xE,
    0x3, 0xA, 0xD, 0xC, 0x1, 0x2, 0x0, 0xB, 0x7, 0x5, 0x9, 0x4, 0x8, 0xF, 0xE, 0x6,
    0xB, 0x5, 0x1, 0x9, 0x8, 0xD, 0xF, 0x0, 0xE, 0x4, 0x2, 0x3, 0xC, 0x7, 0xA, 0x6,
    0xE, 0x7, 0xA, 0xC, 0xD, 0x1, 0x3, 0x9, 0x0, 0x2, 0xB, 0x4, 0xF, 0x8, 0x5, 0x6,
    0xE, 0x4, 0x6, 0x2, 0xB, 0x3, 0xD, 0x8, 0xC, 0xF, 0x5, 0xA, 0x0, 0x7, 0x1, 0x9,
    0x3, 0x7, 0xE, 0x9, 0x8, 0xA, 0xF, 0x0, 0x5, 0x2, 0x6, 0xC, 0xB, 0x4, 0xD, 0x1,
    0x9, 0x6, 0x3, 0x2, 0x8, 0xB, 0x1, 0x7, 0xA, 0x4, 0xE, 0xF, 0xC, 0x0, 0xD, 0x5
};

/** послідовність использования ключа при зашифровании. */
static const uint8_t ENCRYPT_KEY_ORDER[32] = {
    0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,
    0, 1, 2, 3, 4, 5, 6, 7, 7, 6, 5, 4, 3, 2, 1, 0
};

/** послідовність использования ключа при расшифровании. */
static const uint8_t DECRYPT_KEY_ORDER[32] = {
    0, 1, 2, 3, 4, 5, 6, 7, 7, 6, 5, 4, 3, 2, 1, 0,
    7, 6, 5, 4, 3, 2, 1, 0, 7, 6, 5, 4, 3, 2, 1, 0
};

/** послідовність использования ключа при выработке імітовектора. */
static const uint8_t MAC_KEY_ORDER[16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7
};

#define SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, x) (sbox0[(x) & 0xff] | sbox1[((x) >> 8) & 0xff] | sbox2[((x) >> 16) & 0xff] | sbox3[((x) >> 24) & 0xff])
#define FAST_XOR4N(_a, _b, _len, _c)                                                     \
        {                                                                                \
            int _i;                                                                      \
            for (_i = ((_len) >> 2) - 1; _i >= 0; _i--) {                                \
                ((uint32_t *)_c)[_i] = ((uint32_t *)_a)[_i] ^ ((uint32_t *)_b)[_i];      \
            }                                                                            \
        }

#define C1 0x01010101
#define C2 0x01010104

static __inline void base_cycle8(uint32_t *data, const uint32_t *key, const uint8_t *key_order, int len,
        const uint32_t *sbox)
{
    uint32_t s;
    const uint32_t *sbox0 = &sbox[0];
    const uint32_t *sbox1 = &sbox[256];
    const uint32_t *sbox2 = &sbox[512];
    const uint32_t *sbox3 = &sbox[768];

    int i;
    for (i = 0; i < len; i += 4) {
        s = data[0] + key[key_order[i]];
        data[1] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, s);
        s = data[1] + key[key_order[i + 1]];
        data[0] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, s);
        s = data[0] + key[key_order[i + 2]];
        data[1] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, s);
        s = data[1] + key[key_order[i + 3]];
        data[0] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, s);
    }

    if (len == 32) {
        data[0] ^= data[1];
        data[1] ^= data[0];
        data[0] ^= data[1];
    }
}

static __inline void base_cycle24(uint32_t data[6], const uint32_t *key, const uint8_t *key_order,
        const uint32_t *sbox)
{
    uint32_t x1, x2, x3;
    const uint32_t *sbox0 = &sbox[0];
    const uint32_t *sbox1 = &sbox[256];
    const uint32_t *sbox2 = &sbox[512];
    const uint32_t *sbox3 = &sbox[768];
    int i;

    for (i = 0; i < 16; i++) {
        x1 = data[0] + key[key_order[2 * i]];
        x2 = data[2] + key[key_order[2 * i]];
        x3 = data[4] + key[key_order[2 * i]];

        data[1] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, x1);
        data[3] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, x2);
        data[5] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, x3);

        x1 = data[1] + key[key_order[2 * i + 1]];
        x2 = data[3] + key[key_order[2 * i + 1]];
        x3 = data[5] + key[key_order[2 * i + 1]];

        data[0] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, x1);
        data[2] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, x2);
        data[4] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, x3);
    }

    data[0] ^= data[1];
    data[1] ^= data[0];
    data[0] ^= data[1];
    data[2] ^= data[3];
    data[3] ^= data[2];
    data[2] ^= data[3];
    data[4] ^= data[5];
    data[5] ^= data[4];
    data[4] ^= data[5];
}

void base_cycle32(Gost28147Ctx *ctx, uint32_t src[8], const uint32_t k[32])
{
    const uint32_t *k1 = k;
    const uint32_t *k2 = k + 8;
    const uint32_t *k3 = k + 16;
    const uint32_t *k4 = k + 24;
    const uint32_t *sbox0 = &ctx->sbox[0];
    const uint32_t *sbox1 = &ctx->sbox[256];
    const uint32_t *sbox2 = &ctx->sbox[512];
    const uint32_t *sbox3 = &ctx->sbox[768];
    uint32_t x, y, z, r;
    int i;

    for (i = 0; i < 24;) {
        x = src[0] + k1[i & 7];
        y = src[2] + k2[i & 7];
        z = src[4] + k3[i & 7];
        r = src[6] + k4[i++ & 7];

        src[1] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, x);
        src[3] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, y);
        src[5] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, z);
        src[7] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, r);

        x = src[1] + k1[i & 7];
        y = src[3] + k2[i & 7];
        z = src[5] + k3[i & 7];
        r = src[7] + k4[i++ & 7];

        src[0] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, x);
        src[2] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, y);
        src[4] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, z);
        src[6] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, r);
    }

    for (i = 7; i >= 0;) {
        x = src[0] + k1[i];
        y = src[2] + k2[i];
        z = src[4] + k3[i];
        r = src[6] + k4[i--];

        src[1] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, x);
        src[3] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, y);
        src[5] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, z);
        src[7] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, r);

        x = src[1] + k1[i];
        y = src[3] + k2[i];
        z = src[5] + k3[i];
        r = src[7] + k4[i--];

        src[0] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, x);
        src[2] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, y);
        src[4] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, z);
        src[6] ^= SBOX_TRANSFORM(sbox0, sbox1, sbox2, sbox3, r);
    }

    src[0] ^= src[1];
    src[1] ^= src[0];
    src[0] ^= src[1];
    src[2] ^= src[3];
    src[3] ^= src[2];
    src[2] ^= src[3];
    src[4] ^= src[5];
    src[5] ^= src[4];
    src[4] ^= src[5];
    src[6] ^= src[7];
    src[7] ^= src[6];
    src[6] ^= src[7];
}

/**
 * Инкрементирует значення feed.
 *
 * @param feed указатель на 32-байтный feed
 */
static __inline void ctr_next_feed(uint32_t *feed)
{
    int i;
    feed[1] = feed[3 * 2 - 1] + C2;
    feed[0] = feed[3 * 2 - 2] + C1;
    if (feed[1] < C2) {
        feed[1] += 1;
    }

    for (i = 1; i < 3; i++) {
        feed[2 * i + 1] = feed[2 * i - 1] + C2;
        feed[2 * i] = feed[2 * i - 2] + C1;
        if (feed[2 * i + 1] < C2) {
            feed[2 * i + 1] += 1;
        }
    }
}

/* Используется в ГОСТ 28147-89. */
int gost28147_ecb_core(Gost28147Ctx *ctx, const uint8_t *src, size_t len, bool is_encrypt, uint8_t *dst)
{
    uint32_t block24[6] = {0};
    int part_block24_len;
    size_t i;
    int ret = RET_OK;

    CHECK_PARAM(ctx != NULL);
    CHECK_PARAM(src != NULL);
    CHECK_PARAM(dst != NULL);

    /* Шифруем фрагментами по 24 байта. */
    for (i = len / 24; i > 0; i--) {
        DO(uint8_to_uint32(src, 24, block24, 6));
        base_cycle24(block24, ctx->key, is_encrypt ? ENCRYPT_KEY_ORDER : DECRYPT_KEY_ORDER, ctx->sbox);
        DO(uint32_to_uint8(block24, 6, dst, 24));
        src += 24;
        dst += 24;
    }

    /* Шифруем оставшиеся 8 або 16 байт. */
    part_block24_len = len % 24;

    if (part_block24_len != 0) {
        DO(uint8_to_uint32(src, part_block24_len, block24, part_block24_len / 4));
        base_cycle24(block24, ctx->key, is_encrypt ? ENCRYPT_KEY_ORDER : DECRYPT_KEY_ORDER, ctx->sbox);
        DO(uint32_to_uint8(block24, part_block24_len / 4, dst, part_block24_len));
    }

cleanup:
    return ret;
}

static int gost28147_ctr_crypt(Gost28147Ctx *ctx, const uint8_t *src, uint8_t *dst, size_t len)
{
    Gost28147CtrCtx *ctr_ctx = &ctx->mode.ctr;
    size_t ctx_off = ctr_ctx->offset;
    size_t data_off = 0;
    uint32_t feed[6];
    int ret = RET_OK;

    CHECK_PARAM(ctx != NULL);
    CHECK_PARAM(src != NULL);
    CHECK_PARAM(dst != NULL);

    /* Если осталась не использованная часть гаммы. */
    if (ctx_off != 0) {
        while (ctx_off < 24 && data_off < len) {
            dst[data_off] = src[data_off] ^ ctr_ctx->gamma[ctx_off++];
            data_off++;
        }

        if (ctx_off == 24) {
            ctr_next_feed(ctr_ctx->feed);
            memcpy(feed, ctr_ctx->feed, 24);
            base_cycle24(feed, ctx->key, ENCRYPT_KEY_ORDER, ctx->sbox);
            DO(uint32_to_uint8(feed, 6, ctr_ctx->gamma, 24));
            ctx_off = 0;
        }
    }

    if (data_off < len) {
        /* Шифрование блоками по 24 байта. */
        for (; data_off + 24 <= len; data_off += 24) {
            FAST_XOR4N(&src[data_off], ctr_ctx->gamma, 24, &dst[data_off]);
            ctr_next_feed(ctr_ctx->feed);
            memcpy(feed, ctr_ctx->feed, 24);
            base_cycle24(feed, ctx->key, ENCRYPT_KEY_ORDER, ctx->sbox);
            DO(uint32_to_uint8(feed, 6, ctr_ctx->gamma, 24));
        }

        /* Шифрование последнего неполного блока. */
        for (; data_off < len; data_off++) {
            dst[data_off] = src[data_off] ^ ctr_ctx->gamma[ctx_off++];
        }
    }

    ctr_ctx->offset = ctx_off;

cleanup:

    return ret;
}

static int gost28147_cfb_core(Gost28147Ctx *ctx, const uint8_t *src, size_t len, bool is_encrypt, uint8_t *dst)
{
    Gost28147CfbCtx *cfb_ctx = &ctx->mode.cfb;
    uint8_t *gamma = cfb_ctx->gamma;
    uint8_t *feed = cfb_ctx->feed;
    size_t ctx_off = cfb_ctx->offset;
    size_t data_off = 0;
    uint32_t gamma32[2] = {0, 0};
    int ret = RET_OK;

    CHECK_PARAM(ctx != NULL);
    CHECK_PARAM(src != NULL);
    CHECK_PARAM(dst != NULL);

    if (is_encrypt) {
        /* Использование оставшейся гаммы. */
        if (ctx_off != 0) {
            while (ctx_off < 8 && data_off < len) {
                dst[data_off] = src[data_off] ^ gamma[ctx_off];
                feed[ctx_off++] = dst[data_off++];
            }

            if (ctx_off == 8) {
                DO(uint8_to_uint32(feed, 8, gamma32, 2));
                base_cycle8(gamma32, ctx->key, ENCRYPT_KEY_ORDER, 32, ctx->sbox);
                DO(uint32_to_uint8(gamma32, 2, gamma, 8));
                ctx_off = 0;
            }
        }

        if (data_off < len) {
            /* Шифрование блоками по 8 байт. */
            for (; data_off + 8 <= len; data_off += 8) {
                FAST_XOR4N(&src[data_off], gamma, 8, &dst[data_off]);
                memcpy(feed, &dst[data_off], 8);

                DO(uint8_to_uint32(feed, 8, gamma32, 2));
                base_cycle8(gamma32, ctx->key, ENCRYPT_KEY_ORDER, 32, ctx->sbox);
                DO(uint32_to_uint8(gamma32, 2, gamma, 8));
            }
            /* Шифрование последнего неполного блока. */
            for (; data_off < len; data_off++) {
                dst[data_off] = src[data_off] ^ gamma[ctx_off];
                feed[ctx_off++] = dst[data_off];
            }
        }
    } else {
        /* Использование оставшейся гаммы. */
        if (ctx_off != 0) {
            while (ctx_off < 8 && data_off < len) {
                feed[ctx_off] = src[data_off];
                dst[data_off] = src[data_off] ^ gamma[ctx_off++];
                data_off++;
            }

            if (ctx_off == 8) {
                DO(uint8_to_uint32(feed, 8, gamma32, 2));
                base_cycle8(gamma32, ctx->key, ENCRYPT_KEY_ORDER, 32, ctx->sbox);
                DO(uint32_to_uint8(gamma32, 2, gamma, 8));

                ctx_off = 0;
            }
        }

        if (data_off < len) {
            /* Расшифрование блоками по 8 байт. */
            for (; data_off + 8 <= len; data_off += 8) {
                memcpy(feed, &src[data_off], 8);
                FAST_XOR4N(&src[data_off], gamma, 8, &dst[data_off]);

                DO(uint8_to_uint32(feed, 8, gamma32, 2));
                base_cycle8(gamma32, ctx->key, ENCRYPT_KEY_ORDER, 32, ctx->sbox);
                DO(uint32_to_uint8(gamma32, 2, gamma, 8));
            }

            /* Расшифрование последнего неполного блока. */
            for (; data_off < len; data_off++) {
                feed[ctx_off] = src[data_off];
                dst[data_off] = src[data_off] ^ gamma[ctx_off++];
            }
        }
    }

    cfb_ctx->offset = ctx_off;

cleanup:

    return ret;
}

static Gost28147Ctx *gost28147_alloc_user_sbox_core(const uint8_t *sbox, size_t sbox_len)
{
    Gost28147Ctx *ctx = NULL;
    int i;
    int ret = RET_OK;

    CHECK_PARAM(sbox != NULL);
    CHECK_PARAM(sbox_len == SBOX_LEN);

    CALLOC_CHECKED(ctx, sizeof (Gost28147Ctx));

    for (i = 0; i < 256; i++) {
        ctx->sbox[i] = sbox[16 + (i >> 4)] << 4 | sbox[i & 0xf];
        ctx->sbox[256 + i] = (sbox[48 + (i >> 4)] << 4 | sbox[32 + (i & 0xf)]) << 8;
        ctx->sbox[512 + i] = (sbox[80 + (i >> 4)] << 4 | sbox[64 + (i & 0xf)]) << 16;
        ctx->sbox[768 + i] = (sbox[112 + (i >> 4)] << 4 | sbox[96 + (i & 0xf)]) << 24;

        ctx->sbox[i] = (ctx->sbox[i] << 11) | (ctx->sbox[i] >> 21);
        ctx->sbox[256 + i] = (ctx->sbox[256 + i] << 11) | (ctx->sbox[256 + i] >> 21);
        ctx->sbox[512 + i] = (ctx->sbox[512 + i] << 11) | (ctx->sbox[512 + i] >> 21);
        ctx->sbox[768 + i] = (ctx->sbox[768 + i] << 11) | (ctx->sbox[768 + i] >> 21);
    }

    CHECK_NOT_NULL(ctx->sbox128 = ba_alloc_from_uint8(sbox, sbox_len));

    ctx->inited = false;

cleanup:

    if (ret != RET_OK) {
        gost28147_free(ctx);
        ctx = NULL;
    }

    return ctx;
}

Gost28147Ctx *gost28147_alloc(Gost28147SboxId sbox_id)
{
    Gost28147Ctx *ctx = NULL;
    int ret = RET_OK;
    const uint8_t *sbox = NULL;

    switch (sbox_id) {
    case GOST28147_SBOX_DEFAULT:
    case GOST28147_SBOX_ID_1:
        sbox = GOST28147_SBOX_1;
        break;
    case GOST28147_SBOX_ID_2:
        sbox = GOST28147_SBOX_2;
        break;
    case GOST28147_SBOX_ID_3:
        sbox = GOST28147_SBOX_3;
        break;
    case GOST28147_SBOX_ID_4:
        sbox = GOST28147_SBOX_4;
        break;
    case GOST28147_SBOX_ID_5:
        sbox = GOST28147_SBOX_5;
        break;
    case GOST28147_SBOX_ID_6:
        sbox = GOST28147_SBOX_6;
        break;
    case GOST28147_SBOX_ID_7:
        sbox = GOST28147_SBOX_7;
        break;
    case GOST28147_SBOX_ID_8:
        sbox = GOST28147_SBOX_8;
        break;
    case GOST28147_SBOX_ID_9:
        sbox = GOST28147_SBOX_9;
        break;
    case GOST28147_SBOX_ID_10:
        sbox = GOST28147_SBOX_10;
        break;
    case GOST28147_SBOX_ID_11:
        sbox = GOST28147_SBOX_11;
        break;
    case GOST28147_SBOX_ID_12:
        sbox = GOST28147_SBOX_12;
        break;
    case GOST28147_SBOX_ID_13:
        sbox = GOST28147_SBOX_13;
        break;
    case GOST28147_SBOX_ID_14:
        sbox = GOST28147_SBOX_14;
        break;
    case GOST28147_SBOX_ID_15:
        sbox = GOST28147_SBOX_15;
        break;
    case GOST28147_SBOX_ID_16:
        sbox = GOST28147_SBOX_16;
        break;
    case GOST28147_SBOX_ID_17:
        sbox = GOST28147_SBOX_17;
        break;
    case GOST28147_SBOX_ID_18:
        sbox = GOST28147_SBOX_18;
        break;
    default:
        SET_ERROR(RET_INVALID_PARAM);
    }

    CHECK_NOT_NULL(ctx = gost28147_alloc_user_sbox_core(sbox, SBOX_LEN));

cleanup:

    return ctx;
}

Gost28147Ctx *gost28147_alloc_user_sbox(const ByteArray *sbox)
{
    uint8_t buf[SBOX_LEN];
    Gost28147Ctx *ctx = NULL;
    int ret = RET_OK;

    CHECK_PARAM(sbox != NULL);

    DO(ba_to_uint8(sbox, buf, SBOX_LEN));
    CHECK_NOT_NULL(ctx = gost28147_alloc_user_sbox_core(buf, SBOX_LEN));

cleanup:

    return ctx;
}

Gost28147Ctx *gost28147_copy_with_alloc(const Gost28147Ctx *ctx)
{
    Gost28147Ctx *out = NULL;
    int ret = RET_OK;

    CHECK_PARAM(ctx != NULL);

    CALLOC_CHECKED(out, sizeof(Gost28147Ctx));
    memcpy(out, ctx, sizeof(Gost28147Ctx));
    CHECK_NOT_NULL(out->sbox128 = ba_copy_with_alloc(ctx->sbox128, 0, 0));

cleanup:

    if (ret != RET_OK) {
        gost28147_free(out);
        out = NULL;
    }

    return out;
}

int gost28147_get_ext_sbox(const Gost28147Ctx *ctx, ByteArray **sbox)
{
    int ret = RET_OK;

    CHECK_PARAM(ctx != NULL);
    CHECK_PARAM(sbox != NULL);

    CHECK_NOT_NULL(*sbox = ba_alloc_from_uint8(ctx->sbox128->buf, ctx->sbox128->len));

cleanup:

    return ret;
}

int gost28147_get_compress_sbox(const Gost28147Ctx *ctx, ByteArray **sbox)
{
    int i, j, ret = RET_OK;
    uint8_t compress_sbox[64];

    CHECK_PARAM(ctx != NULL);
    CHECK_PARAM(sbox != NULL);

    memset(compress_sbox, 0, sizeof(compress_sbox));

    for (i = 0; i < 8; i++) {
        for (j = 0; j < 16; j++) {
            compress_sbox[(i << 3) + (j >> 1)] |= ((ctx->sbox128->buf[16 * i + j] << ((~j & 1) << 2)));
        }
    }

    CHECK_NOT_NULL(*sbox = ba_alloc_from_uint8(compress_sbox, sizeof(compress_sbox)));

cleanup:

    return ret;
}

int gost28147_generate_key(ByteArray **key)
{
    int ret = RET_OK;
    ByteArray *k = NULL;

    CHECK_NOT_NULL(k = ba_alloc_by_len(32));
    DO(drbg_random(k));

    *key = k;
    k = NULL;

cleanup:

    ba_free(k);
    return ret;
}


int gost28147_init_ecb(Gost28147Ctx *ctx, const ByteArray *key)
{
    int ret = RET_OK;

    CHECK_PARAM(ctx != NULL);
    CHECK_PARAM(key != NULL);
    CHECK_PARAM(ba_get_len(key) == KEY_LEN);

    ctx->mode_id = GOST28147_MODE_ECB;
    DO(ba_to_uint32(key, ctx->key, KEY_LEN / UINT32_LEN));
    ctx->inited = true;

cleanup:

    return ret;
}

int gost28147_init_ctr(Gost28147Ctx *ctx, const ByteArray *key, const ByteArray *iv)
{
    Gost28147CtrCtx *ctr_ctx = &ctx->mode.ctr;
    int ret = RET_OK;

    CHECK_PARAM(ctx != NULL);
    CHECK_PARAM(key != NULL);
    CHECK_PARAM(iv != NULL);
    CHECK_PARAM(key->len == KEY_LEN);
    CHECK_PARAM(iv->len == IV_LEN);

    ctx->mode_id = GOST28147_MODE_CTR;
    DO(ba_to_uint32(key, ctx->key, KEY_LEN / UINT32_LEN));
    DO(uint8_to_uint32(ba_get_buf_const(iv), IV_LEN, &ctr_ctx->feed[4], 2));
    base_cycle8(&ctr_ctx->feed[4], ctx->key, ENCRYPT_KEY_ORDER, 32, ctx->sbox);
    ctr_ctx->offset = 24;
    ctx->inited = true;

cleanup:

    return ret;
}

int gost28147_init_cfb(Gost28147Ctx *ctx, const ByteArray *key, const ByteArray *iv)
{
    Gost28147CfbCtx *cfb_ctx = &ctx->mode.cfb;
    int ret = RET_OK;

    CHECK_PARAM(ctx != NULL);
    CHECK_PARAM(key != NULL);
    CHECK_PARAM(iv != NULL);
    CHECK_PARAM(key->len == KEY_LEN);
    CHECK_PARAM(iv->len == IV_LEN);

    ctx->mode_id = GOST28147_MODE_CFB;
    DO(ba_to_uint32(key, ctx->key, KEY_LEN / UINT32_LEN));
    DO(ba_to_uint8(iv, cfb_ctx->feed, IV_LEN));
    cfb_ctx->offset = 8;
    ctx->inited = true;

cleanup:

    return ret;
}

int gost28147_init_mac(Gost28147Ctx *ctx, const ByteArray *key)
{
    Gost28147MacCtx *mac_ctx = &ctx->mode.mac;
    int ret = RET_OK;

    CHECK_PARAM(ctx != NULL);
    CHECK_PARAM(key != NULL);
    CHECK_PARAM(key->len == KEY_LEN);

    ctx->mode_id = GOST28147_MODE_MAC;
    DO(ba_to_uint32(key, ctx->key, KEY_LEN / UINT32_LEN));
    memset(mac_ctx->mac, 0, 8);
    mac_ctx->offset = 0;
    ctx->inited = true;

cleanup:

    return ret;
}

int gost28147_encrypt(Gost28147Ctx *ctx, const ByteArray *in, ByteArray **out)
{
    size_t len;
    uint8_t *out_buf = NULL;
    int ret = RET_OK;

    CHECK_PARAM(ctx != NULL);
    CHECK_PARAM(in != NULL);
    CHECK_PARAM(out != NULL);

    len = in->len;

    if (!ctx->inited) {
        SET_ERROR(RET_CONTEXT_NOT_READY);
    }

    switch (ctx->mode_id) {
    case GOST28147_MODE_ECB:
        CHECK_PARAM((len & 0x7) == 0);

        MALLOC_CHECKED(out_buf, len);
        DO(gost28147_ecb_core(ctx, ba_get_buf_const(in), len, true, out_buf));
        break;
    case GOST28147_MODE_CTR:
        MALLOC_CHECKED(out_buf, len);
        DO(gost28147_ctr_crypt(ctx, ba_get_buf_const(in), out_buf, len));
        break;
    case GOST28147_MODE_CFB:
        MALLOC_CHECKED(out_buf, len);
        DO(gost28147_cfb_core(ctx, ba_get_buf_const(in), len, true, out_buf));
        break;
    case GOST28147_MODE_MAC:
    default:
        SET_ERROR(RET_INVALID_CTX_MODE);
    }

    CHECK_NOT_NULL(*out = ba_alloc());
    (*out)->buf = out_buf;
    (*out)->len = len;
    out_buf = NULL;

cleanup:
    free(out_buf);
    return ret;
}

int gost28147_decrypt(Gost28147Ctx *ctx, const ByteArray *in, ByteArray **out)
{
    size_t len;
    uint8_t *out_buf = NULL;
    int ret = RET_OK;

    CHECK_PARAM(ctx != NULL);
    CHECK_PARAM(in != NULL);
    CHECK_PARAM(out != NULL);

    len = ba_get_len(in);

    if (!ctx->inited) {
        SET_ERROR(RET_CONTEXT_NOT_READY);
    }

    switch (ctx->mode_id) {
    case GOST28147_MODE_ECB:
        CHECK_PARAM((len & 0x7) == 0);

        MALLOC_CHECKED(out_buf, len);
        DO(gost28147_ecb_core(ctx, ba_get_buf_const(in), len, false, out_buf));
        break;
    case GOST28147_MODE_CTR:
        MALLOC_CHECKED(out_buf, len);
        DO(gost28147_ctr_crypt(ctx, ba_get_buf_const(in), out_buf, len));
        break;
    case GOST28147_MODE_CFB:
        MALLOC_CHECKED(out_buf, len);
        DO(gost28147_cfb_core(ctx, ba_get_buf_const(in), len, false, out_buf));
        break;
    case GOST28147_MODE_MAC:
    default:
        SET_ERROR(RET_INVALID_CTX_MODE);
    }

    CHECK_NOT_NULL(*out = ba_alloc());
    (*out)->buf = out_buf;
    (*out)->len = len;
    out_buf = NULL;

cleanup:
    free(out_buf);
    return ret;
}

int gost28147_update_mac(Gost28147Ctx *ctx, const ByteArray *in)
{
    const uint8_t *src;
    size_t len;
    uint32_t mac32[2];
    Gost28147MacCtx *mac_ctx = NULL;
    size_t ctx_off;
    size_t data_off = 0;
    int ret = RET_OK;

    CHECK_PARAM(ctx != NULL);
    CHECK_PARAM(in != NULL);

    len = ba_get_len(in);

    if (ctx->mode_id != GOST28147_MODE_MAC) {
        SET_ERROR(RET_INVALID_CTX_MODE);
    }

    if (!ctx->inited) {
        SET_ERROR(RET_CONTEXT_NOT_READY);
    }

    mac_ctx = &ctx->mode.mac;
    ctx_off = mac_ctx->offset;
    src = ba_get_buf_const(in);

    if (ctx_off != 0) {
        while (ctx_off < 8 && data_off < len) {
            mac_ctx->mac[ctx_off++] ^= src[data_off++];
        }

        if (ctx_off == 8) {
            DO(uint8_to_uint32(mac_ctx->mac, 8, mac32, 2));
            base_cycle8(mac32, ctx->key, MAC_KEY_ORDER, 16, ctx->sbox);
            DO(uint32_to_uint8(mac32, 2, mac_ctx->mac, 8));
            ctx_off = 0;
        }
    }

    if (data_off < len) {
        for (; data_off + 8 <= len; data_off += 8) {
            FAST_XOR4N(&src[data_off], mac_ctx->mac, 8, mac_ctx->mac);
            DO(uint8_to_uint32(mac_ctx->mac, 8, mac32, 2));
            base_cycle8(mac32, ctx->key, MAC_KEY_ORDER, 16, ctx->sbox);
            DO(uint32_to_uint8(mac32, 2, mac_ctx->mac, 8));
        }

        while (data_off < len) {
            mac_ctx->mac[ctx_off++] ^= src[data_off++];
        }
    }

    mac_ctx->offset = ctx_off;

cleanup:

    return ret;
}

int gost28147_final_mac(Gost28147Ctx *ctx, ByteArray **out)
{
    Gost28147MacCtx *mac_ctx = NULL;
    uint32_t mac32[2];
    int ret = RET_OK;

    CHECK_PARAM(ctx != NULL);
    CHECK_PARAM(out != NULL);

    if (ctx->mode_id != GOST28147_MODE_MAC) {
        SET_ERROR(RET_INVALID_CTX_MODE);
    }

    if (!ctx->inited) {
        SET_ERROR(RET_CONTEXT_NOT_READY);
    }

    mac_ctx = &ctx->mode.mac;

    if (mac_ctx->offset != 0) {
        DO(uint8_to_uint32(mac_ctx->mac, 8, mac32, 2));
        base_cycle8(mac32, ctx->key, MAC_KEY_ORDER, 16, ctx->sbox);
        DO(uint32_to_uint8(mac32, 2, mac_ctx->mac, 8));
        mac_ctx->offset = 0;
    }

    CHECK_NOT_NULL(*out = ba_alloc_from_uint8(mac_ctx->mac, 4));
    memset(mac_ctx->mac, 0, 8);

cleanup:

    return ret;
}

int gost28147_final_mac8(Gost28147Ctx *ctx, ByteArray **out)
{
    Gost28147MacCtx *mac_ctx;
    uint32_t mac32[2];
    int ret = RET_OK;

    CHECK_PARAM(ctx != NULL);
    CHECK_PARAM(out != NULL);

    if (ctx->mode_id != GOST28147_MODE_MAC) {
        SET_ERROR(RET_INVALID_CTX_MODE);
    }

    if (!ctx->inited) {
        SET_ERROR(RET_CONTEXT_NOT_READY);
    }

    mac_ctx = &ctx->mode.mac;

    if (mac_ctx->offset != 0) {
        DO(uint8_to_uint32(mac_ctx->mac, 8, mac32, 2));
        base_cycle8(mac32, ctx->key, MAC_KEY_ORDER, 16, ctx->sbox);
        DO(uint32_to_uint8(mac32, 2, mac_ctx->mac, 8));
        mac_ctx->offset = 0;
    }

    CHECK_NOT_NULL(*out = ba_alloc_from_uint8(mac_ctx->mac, 8));
    memset(mac_ctx->mac, 0, 8);

cleanup:

    return ret;
}

void gost28147_free(Gost28147Ctx *ctx)
{
    if (ctx != NULL) {
        ba_free_private(ctx->sbox128);
        secure_zero(ctx, sizeof(Gost28147Ctx));
        free(ctx);
    }
}

static int gost28147_ecb_self_test(void)
{
    int ret = RET_OK;
    Gost28147Ctx* ctx = NULL;
    ByteArray* key = ba_alloc_from_hex("348724a4c1a67667153dde5933884250e3248c657d413b8c1c9ca09a56d968cf");
    ByteArray* data = ba_alloc_from_hex("34c01533e37d1c56e9431604f57e37a18f90eb0333a33362");
    ByteArray* enc_expected = ba_alloc_from_hex("863e78dd2d60d13ce38f0f691f68f7feb99bb76c3073142d");
    ByteArray* enc_actual = NULL;
    ByteArray* dec_actual = NULL;

    CHECK_NOT_NULL(ctx = gost28147_alloc(GOST28147_SBOX_ID_11));

    DO(gost28147_init_ecb(ctx, key));
    DO(gost28147_encrypt(ctx, data, &enc_actual));
    if (ba_cmp(enc_expected, enc_actual) != 0) {
        SET_ERROR(RET_SELF_TEST_FAIL);
    }

    DO(gost28147_decrypt(ctx, enc_actual, &dec_actual));
    if (ba_cmp(data, dec_actual) != 0) {
        SET_ERROR(RET_SELF_TEST_FAIL);
    }

cleanup:
    ba_free(key);
    ba_free(data);
    ba_free(enc_expected);
    ba_free(enc_actual);
    ba_free(dec_actual);
    gost28147_free(ctx);
    return ret;
}

static int gost28147_ctr_self_test(void)
{
    int ret = RET_OK;
    Gost28147Ctx* ctx = NULL;
    ByteArray* key = ba_alloc_from_hex("0100000002000000030000000400000005000000060000000700000008000000");
    ByteArray* iv = ba_alloc_from_hex("0300000003000000");
    ByteArray* data = ba_alloc_from_hex("0102030405060708090a0b0c0d0e0f101112131415161718");
    ByteArray* enc_expected = ba_alloc_from_hex("da21005efbea34aa48d17ebf1c4f52a18eca42d3ff4b46f4");
    ByteArray* enc_actual = NULL;

    CHECK_NOT_NULL(ctx = gost28147_alloc(GOST28147_SBOX_ID_11));

    DO(gost28147_init_ctr(ctx, key, iv));
    DO(gost28147_encrypt(ctx, data, &enc_actual));
    if (ba_cmp(enc_expected, enc_actual) != 0) {
        SET_ERROR(RET_SELF_TEST_FAIL);
    }

cleanup:
    ba_free(key);
    ba_free(data);
    ba_free(iv);
    ba_free(enc_expected);
    ba_free(enc_actual);
    gost28147_free(ctx);
    return ret;
}

static int gost28147_cfb_self_test(void)
{
    int ret = RET_OK;
    Gost28147Ctx* ctx = NULL;
    ByteArray* key = ba_alloc_from_hex("0100000002000000030000000400000005000000060000000700000008000000");
    ByteArray* iv = ba_alloc_from_hex("0300000003000000");
    ByteArray* data = ba_alloc_from_hex("0102030405060708090a0b0c0d0e0f101112131415161718");
    ByteArray* enc_expected = ba_alloc_from_hex("d1ce841aa50de523b0ab76646f0d1ee8ae02aa0c4e8eafb3");
    ByteArray* enc_actual = NULL;
    ByteArray* dec_actual = NULL;

    CHECK_NOT_NULL(ctx = gost28147_alloc(GOST28147_SBOX_ID_11));

    DO(gost28147_init_cfb(ctx, key, iv));
    DO(gost28147_encrypt(ctx, data, &enc_actual));
    if (ba_cmp(enc_expected, enc_actual) != 0) {
        SET_ERROR(RET_SELF_TEST_FAIL);
    }

    DO(gost28147_init_cfb(ctx, key, iv));
    DO(gost28147_decrypt(ctx, enc_actual, &dec_actual));
    if (ba_cmp(data, dec_actual) != 0) {
        SET_ERROR(RET_SELF_TEST_FAIL);
    }

cleanup:
    ba_free(key);
    ba_free(data);
    ba_free(iv);
    ba_free(enc_expected);
    ba_free(enc_actual);
    ba_free(dec_actual);
    gost28147_free(ctx);
    return ret;
}

static int gost28147_mac_self_test(void)
{
    int ret = RET_OK;
    Gost28147Ctx* ctx = NULL;
    ByteArray* key = ba_alloc_from_hex("0100000002000000030000000400000005000000060000000700000008000000");
    ByteArray* data = ba_alloc_from_hex("d1ce841aa50de523b0ab76646f0d1ee8ae02aa0c4e8eafb3");
    ByteArray* mac_exp = ba_alloc_from_hex("7e4a9667");
    ByteArray* mac_act = NULL;

    CHECK_NOT_NULL(ctx = gost28147_alloc(GOST28147_SBOX_ID_11));
    DO(gost28147_init_mac(ctx, key));
    DO(gost28147_update_mac(ctx, data));
    DO(gost28147_final_mac(ctx, &mac_act));
    if (ba_cmp(mac_exp, mac_act) != 0) {
        SET_ERROR(RET_SELF_TEST_FAIL);
    }

cleanup:

    ba_free(key);
    ba_free(data);
    ba_free(mac_exp);
    ba_free(mac_act);
    gost28147_free(ctx);
    return ret;
}

int gost28147_self_test(void)
{
    int ret = RET_OK;

    DO(gost28147_ecb_self_test());
    DO(gost28147_ctr_self_test());
    DO(gost28147_cfb_self_test());
    DO(gost28147_mac_self_test());

cleanup:
    return ret;
}
